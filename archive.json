{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-13T00:02:21.413527+00:00",
  "repo": "heymarcel/draft-ietf-wimse-headless-jwt-authentication",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOOVtHv86xlvim",
      "title": "Change Title",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/1",
      "state": "CLOSED",
      "author": "PieterKas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Suggest to drop the \"Practices\" from the specification - WIMSE Headless JWT Authentication",
      "createdAt": "2025-04-08T11:15:50Z",
      "updatedAt": "2025-04-08T15:29:24Z",
      "closedAt": "2025-04-08T15:29:23Z",
      "comments": [
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Agreed. Changed as part of merge from PR #2 ",
          "createdAt": "2025-04-08T15:29:23Z",
          "updatedAt": "2025-04-08T15:29:23Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOOVtHv86y2rYT",
      "title": "Simplify diagram",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/3",
      "state": "CLOSED",
      "author": "heymarcel",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "* Take out the call to `/.well-known/openid-configuration` -- we can just explain elsewhere in the document.\n* Number the \"initial provisioning\" step, and add to \"JWT used for Authentication\"\n",
      "createdAt": "2025-04-16T20:32:10Z",
      "updatedAt": "2025-04-30T23:43:07Z",
      "closedAt": "2025-04-30T23:43:07Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOOVtHv86y2r_R",
      "title": "Fill out \"JWT Format\" and \"JWT Processing\"",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/4",
      "state": "CLOSED",
      "author": "heymarcel",
      "authorAssociation": "OWNER",
      "assignees": [
        "heymarcel"
      ],
      "labels": [],
      "body": "See the TODOs.",
      "createdAt": "2025-04-16T20:33:41Z",
      "updatedAt": "2025-04-25T01:05:33Z",
      "closedAt": "2025-04-25T01:05:33Z",
      "comments": [
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Added an example JWT in this commit: 4643dd74e3ff84abb925d434518922372e02940a",
          "createdAt": "2025-04-16T22:31:18Z",
          "updatedAt": "2025-04-16T22:31:28Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOOVtHv86y2tC1",
      "title": "Add more detail to \"JWT Provisioning\"",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/5",
      "state": "CLOSED",
      "author": "heymarcel",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We can reference the Client Credentials flow here, for example.",
      "createdAt": "2025-04-16T20:35:35Z",
      "updatedAt": "2025-04-30T23:03:20Z",
      "closedAt": "2025-04-30T23:03:19Z",
      "comments": [
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Fixed in 323366dfb50b4b1e55efc34b0ba09c870fbef452",
          "createdAt": "2025-04-30T23:03:19Z",
          "updatedAt": "2025-04-30T23:03:19Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOOVtHv86y2tSL",
      "title": "Address the issue of client registration",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/6",
      "state": "OPEN",
      "author": "heymarcel",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "It's not mentioned at all in the spec, but it does need to be dealt with.",
      "createdAt": "2025-04-16T20:36:10Z",
      "updatedAt": "2025-05-09T21:39:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 7523 states that client ID is optional when using the JWT as an authorization grant. Since that seems to be the goal, more so than client authentication, perhaps we don't need client registration for this speccification.\n\nanother path to explore is whether we do implicit registration - for example, the JWT was issued by a trusted entitiy, the \"sub\" claim can be trusted as the identity of the workload. An AS my decide that given that it trusts the JWT issuer, it also trust the \"sub\" and treats it as an act of registration. In essence, it outsorces client registration to the JWT issuer. The AS may maintain its own mapping of \"sub\" to some kind of \"client_id\" internally, but that is an implementation detail.\n\nBasically a variation of this: https://www.linkedin.com/posts/pieter-kasselman-0259862_spiffe-oauth-mcp-activity-7314979089797296128-gkw2?utm_source=share&utm_medium=member_desktop&rcm=ACoAAAB__J0Bpgv2Y6ZcpNNGu7FxZiO5luiLBxc",
          "createdAt": "2025-05-01T10:19:18Z",
          "updatedAt": "2025-05-01T10:20:00Z"
        },
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Take a look at #9 for this as well.",
          "createdAt": "2025-05-05T21:28:30Z",
          "updatedAt": "2025-05-05T21:28:30Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOOVtHv860XGa7",
      "title": "\"Client ID Context\" problem - how does the receiving domain figure out which client ID is being authenticated?",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/8",
      "state": "OPEN",
      "author": "hpsin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In [RFC 6749 #3.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1) and 4.4, we find that it doesn't appear to be mandatory for a client_credentials caller to actually specify which client_id they intend to authenticate for. The client secret is assumed to be sufficient to figure out which client_id is being authenticated. \n\nThat's not true though for these federated credentials - it's reasonable to say that a workload in the issuing domain is allowed to sign in to 3 different receiving domain `client_id`s with the same issuer/sub/aud claims. As a result, if the receiving AS gets a request with this JWT and no identifying client_id, it can't accurately deduce which client_id to issue a token for. \n\nSo... given a bare JWT and some scopes, how does the receiving domain know which client ID to sign in for?\nGitHub has this problem here: https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#get-the-authenticated-app\n\nAnd in general the [installation token API](https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-an-installation-access-token-for-an-app) does not indicate which GitHub App is being signed into. Instead, we look for the `appid` in the JWT, and ensure that the installation ID is a valid installation for that app. \n\nNon-standard implementations of this pattern, and even standard implementations (assuming that the client_credentials flow will be the standard path here) will require some amount of help to identify the client_id.\n\nOptions I can think of that solve some or all of the issue: \n1. A `client_id` claim in the JWT?\n    * Some better name for that claim that makes it clear it's the client ID in the receiving domain?\n2. Indicate that `client_ID` is required in this scenario for all flows. \n   * For scenarios that aren't client credentials (so all my GitHub scenarios), require support for a parameter that represents the client ID\n3. Mandate that the triplet of issuer/subject/audience is unique within a receiving domain - only one client_id can use a particular triplet. \n\nAll of these are problematic:\n1. Claim injection is not evenly supported in many IDPs. For example, they can be injected in Entra but only via relatively expensive [custom claims](https://learn.microsoft.com/en-us/entra/identity-platform/custom-claims-provider-reference) or fixed-format claims which would not match a standardized claim (`extn_{GUID for the client}_claimname`). \n2. This is a compat issue for existing code that wants to update from using self-signed JWTs in client_credentials flows to issued JWTs. It doesn't always fit cleanly into existing APIs either - e.g. `/app` on GitHub, do we accept a query parameter there? A bit ugly. \n3. This is a scenario blocker for users. It's reasonable that we have cardinality mismatches between the domains - i.e. one production workload in the issuing domain, but test, dev, and prod clients in the receiving domain that all need to trust the same workload's JWT. ",
      "createdAt": "2025-04-28T19:31:02Z",
      "updatedAt": "2025-05-09T21:39:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Summary of further discussion in Slack:\n\n1. In the context of GitHub, an App is owned by an Account. (There are three different types of Accounts: User, Organization, and Enterprise).\n2. A field _like_ `client_id` is the easiest way to correlate a JWT to an App \n3. This naturally turns into an M:N mapping (See Hirsch's example below)\n\n> So 6 workloads are linked to 4 identities.\n> W1-6 are all attached to ID1.\n> W2 is attached to all 4 IDs.\n> W3 and W4 are attached to ID3.\n> etc...\n\nNote that we'll see this concept of \"resource\" within \"account\" in many other providers (e.g. AWS).\n\nIn terms of solving the issue, perhaps we don't present a single option, but discuss the problem in \"Interoperability\", along with some or all of the options you've presented.\n\nSpeaking of the options, I'm not sure I'm keen on number 3, not only for the reason you mentioned, but also because I don't believe that this will be enforced enough in practice to be reliable.  \n \nThe current draft mentions that the `sub` claim need not equal the `client_id`, but that's also an option.",
          "createdAt": "2025-04-29T17:30:20Z",
          "updatedAt": "2025-04-29T17:30:20Z"
        },
        {
          "author": "hpsin",
          "authorAssociation": "NONE",
          "body": "> The current draft mentions that the sub claim need not equal the client_id, but that's also an option.\n\nI think that will be difficult to support. Imagine an IDP issuing JWTs for multiple workloads, federating with multiple domains. So e.g. a central SPIFFE issuer giving tokens to a workload, for use with JFrog, GitHub, and FooSaaS. \n\nEach of JFrog, GitHub, and FooSaaS are going to track their own `client_id` for the app in their domain. So in GitHub, we call the workload \"client_id=182745\". In JFrog the workload is given the client_id `customer123.app42`. And FooSaaS uses URIs for client_ids, so they expect a token with `client_id=Foo://customer123/group1/bar`. \n\nIs the token issuer going to track which subject to use with which audience? What happens when two audiences use the same client ID to reference different apps? I don't think there's a world where the `sub` claim is _ever_ going to be a value that is derived from the receiving domain. ",
          "createdAt": "2025-04-29T23:33:15Z",
          "updatedAt": "2025-04-29T23:33:29Z"
        },
        {
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC7523 (https://datatracker.ietf.org/doc/html/rfc7523#section-2.1) states that client_id is optional when the JWT is used as an Authorization Grant.\n\n@hpsin I am trying to understand this a bit better:\n\n> That's not true though for these federated credentials - it's reasonable to say that a workload in the issuing domain is allowed > to sign in to 3 different receiving domain client_ids with the same issuer/sub/aud claims. As a result, if the receiving AS gets a > request with this JWT and no identifying client_id, it can't accurately deduce which client_id to issue a token for.\n\nWhat does \"a workload in the issuing domain is allowed to sign in to 3 different receiving domain client_ids\" mean? \n\nWhat is issueing domain vs receiving domain?\n\nAre you saying that you have a scenario where a single workload with a single JWT may act as three distinct clients with the same Authorization Server when requesting an Access Token? Does the AS use the client_id as part of the authorisation decision (apart from the fact that it is registered) before issueing the Access Token?\n\n",
          "createdAt": "2025-04-30T20:14:46Z",
          "updatedAt": "2025-04-30T20:14:46Z"
        },
        {
          "author": "hpsin",
          "authorAssociation": "NONE",
          "body": "I was just creating another issue to try and standardize on some names and labels for the various actors here. \n\nAnd yes, that was my fear was that the client_id is optional, however it does indicate that it's \"only needed when a form of client authentication that relies on the parameter is used.\" I think this is referring to basic auth versus not, however. \n\nI'm trying to find appropriate words to describe the two trust domains in play here - the \"issuing\" domain is the one that owns the IDP that issues the JWT that is used for federation. The \"receiving\" domain is the domain that validates the JWT and issues a new token in response, for an identity that is managed within that domain. The net is that the \"issuing domain workload\" (e.g. a Jenkins pipeline in a customer environment that was given a JWT SVID) is able to run the token exchange to get a token and assumed identity within the \"receiving domain\" (e.g. using that SVID with an Entra FIC to get an Entra-issued access token with which to call Azure APIs).\n\nTo extend the scenario - consider a single pipeline that needs to assume the identities of three different Entra service principals. Each SP would have a FIC on it that points to the pipeline's identity. Naively, we would expect the FIC `aud` to be \"Entra\", the `sub` to  be the pipeline's SPIFFE ID, and the `iss` to be the customer's SPIFFE issuer. \n\nMy concern (perhaps specific to API design problems in GitHub) is that this is a single token that can be used in an exchange with Entra to assume one of three service principal identities. The standard JWT claims on their own cannot be used to determine _which_ of the identities to assume - that detail must be provided in some way through one of the methods I described, or the confusion cannot be allowed to occur. \n\nI think this can be called a modeling problem, and not allowing multiple identical FICS is a valid solution, as we've sat on this some more - those three FICs should not share an `aud` claim because they are not the same identity. Instead they should be represented as three distinct token audiences within the SPIFFE setup, and the pipeline should request _three_ tokens from the SPIFFE provider - one for each of the identities it wishes to assume within Entra. \n\n",
          "createdAt": "2025-04-30T21:04:47Z",
          "updatedAt": "2025-04-30T21:04:47Z"
        },
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "I wouldn't limit the concern to GitHub/Entra. It's likely that other systems would solve the same problem in a similar way. Even if we could solve it by, say, adding values to the \"aud\" claim, we would be kicking the can down the road. The problem reminds me a bit of hosting providers who would jam as many domains into a single certificate as possible in order to save on load balancers. In these cases, the issuing mechanism ends up having to \"know\" more about the usage of the token than it should.\n\nI'm fine with adding an opinion in the interoperability section that states that these tokens should not share an \"aud\" claim. That would give you the unique iss/sub/aud tuple you mentioned earlier, even if the iss/sub remains the same across the tokens. ",
          "createdAt": "2025-04-30T22:59:48Z",
          "updatedAt": "2025-04-30T22:59:48Z"
        },
        {
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I understand the scenario now @hpsin.\n\n1. A workload is issued with a JWT containing a \"sub\" (it's SPIFFE ID), \"aud\" (the Authorization server in the receiving domain), and an \"iss\" (the SPIFFE issuer).\n2. The receiving domain authorization server protects numerous resources. It figures out which resource the workload that is presenting the JWT SVID is trying to access.\n3. The receiving domain's authorisation server issues the access token for the specific resource server.\n4. The workload present the Access Token to the Resource Server to gain access.\n\nA few thoughts:\n\nToken Claims\n-------------\nThe \"aud\" claim should be used to identify the receiving domain's authorization server. This should probably be a single \"aud\" value.\n\nThe \"sub\" claim should uniquely identify the workload. The receiving domain's authorization server may apply some kind of wildcarding (e.g. some SPIFFE IDs may have regional or cluster specific information included, which may not be relevant to the receiving domain's decision on whether to accept the token). Some common sense constraints should be enforced though (allow * seems harmful for example). Implementation and support is at the discretion of the receiving domain's authorization server.\n\nThe \"iss\" claim indicates the SPIFFE issuer. This should be matched to the JWKs discovery point that was previously configured for validation.\n\nResource Server Selection\n--------------------------\nDetermining which resource the workload is requesting access to should probably not be treated as a credential format problem or a client_id problem. Instead, we should consider treating this as a protocol problem and letting the workload specify which resource it is trying to access. \n\nThe receiving domain's authorization server can maintain a list of resources for which the \"sub\" is allowed to request an Access Token (this is setup at the same time as the JWKS URL, sub, aud and other claims). Some ideas on how the workload can indicate which resource it wants to access:\n\n1. RFC 8707 is dedicated to describing the \"resource\" parameter (https://www.rfc-editor.org/rfc/rfc8707.html). This seems like an easy extension to support. We can introduce this as a SHOULD or a MUST when using the JWT as an Authorisation Grant as specified in RFC 7523.\n2. We can specify that the resource for which the workload is requesting and Access Token be indicated through the \"scope\" parameter. This may be a pragmatic alternative to RFC 8707, although it is probably bending the purpose/use of the \"scope\" parameter.\n",
          "createdAt": "2025-05-01T10:13:32Z",
          "updatedAt": "2025-05-01T10:13:32Z"
        },
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Here's an initial attempt to address some of the topics in this discussion: #9 ",
          "createdAt": "2025-05-05T21:28:02Z",
          "updatedAt": "2025-05-05T21:28:02Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOOVtHv861mH3D",
      "title": "Security considerations for control flow claims versus request parameters",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/10",
      "state": "OPEN",
      "author": "hpsin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Consumers of this pattern will need to (be able to) choose between performance and security, particularly in scenarios where there are many issuing domain workloads being mapped to a single resource domain principal, or one issuing domain workload being mapped to multiple resource domain principals. \n\nIn both cases, either preference may be possible:\n* Reuse a single token across multiple exchanges for multiple principals, getting performance at the risk of worse security (due to token reuse)\n* Require a distinct token for each exchange to guarantee that tokens cannot be reused improperly. \n\nThe latter is generally preferred, and would be ensured by adding additional unique data within the federating JWT to lock down how it can be used (for instance, by extending the subject claim to reference a specific issuing domain workload, including a claim that specifies a specific resource domain principal, or resource domain specific claims that help scope the resulting token).\n\nTo support this, both the issuing IDP and the authorizing resource AS should support this pattern:\n1. The issuing IDP needs to be able to inject claims (via some unspecified configuration) in response to runtime instructions and specific subject/audience combinations. These should be able to take any (unclaimed? i.e. can't be `sub`) claim name, to ensure compatibility with resource domain AS logic. \n2. The resource domain AS should support validating multiple custom claims in the token, and establish a known way of specifying the resource domain principal ID within the JWT, which allows the AS to better ensure that tokens cannot be reused across principals. \n3. The resource domain AS should support any runtime parameters they offer (for instance, the `scopes` parameter) being included in the JWT instead, and either only obey the JWT claims if present or take the most restrictive union of outcomes from JWT claims and runtime parameters, if both are present. \n    * For instance, GitHub supports \"[scoped tokens](https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-an-installation-access-token-for-an-app)\", where the access token being requested can be scoped down to specific permissions by the inclusion of runtime parameters (`repositories` and `permissions`). It would be beneficial for security outcomes to enable an issuing IDP to mint a JWT that contains these two claims, thus restricting the workload to just those chosen repos and permissions in a way that cannot be tampered with by the workload. \n\n\nThe other alternative is to inject these signals to the AS at runtime, via request parameters. These are not enforced by the IDP, which allows for token reuse in ways that may be desired. For instance, a workload sometimes needs a tightly scoped resource access token, and sometimes wants a full-strength access token, and would use the runtime request parameters to alter the resulting token instead of relying on its IDP to provide multiple JWTs for use with the audience. This may be required for compatibility purposes as well, if the IDP or resource AS do not adequately support claim injection and validation. ",
      "createdAt": "2025-05-07T17:21:05Z",
      "updatedAt": "2025-05-08T19:58:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hpsin",
          "authorAssociation": "NONE",
          "body": "AWS uses https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html\n\nGoogle uses https://cloud.google.com/iam/docs/workload-identity-federation#mapping which is \"[common expression language](https://github.com/google/cel-spec/blob/master/doc/intro.md#introduction)\"\n\n",
          "createdAt": "2025-05-08T19:58:42Z",
          "updatedAt": "2025-05-08T19:58:42Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOOVtHv861mo0s",
      "title": "Security Considerations: Use multiple signing keys",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/11",
      "state": "OPEN",
      "author": "PieterKas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Following on from conversation - addd security considerations to use uniqque keys per account when issuing a token after a successful authentication.",
      "createdAt": "2025-05-07T18:14:18Z",
      "updatedAt": "2025-05-09T23:27:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "I've added this on to #9 ",
          "createdAt": "2025-05-09T23:27:21Z",
          "updatedAt": "2025-05-09T23:27:21Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOOVtHv861mpZ_",
      "title": "Security Considerations: Claims transcriptions",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/12",
      "state": "OPEN",
      "author": "PieterKas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add security considerations on risks of transcribing new claims from a JWT that was presented.",
      "createdAt": "2025-05-07T18:15:27Z",
      "updatedAt": "2025-05-09T21:38:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOOVtHv861xZ4R",
      "title": "Two level trust establishment",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/13",
      "state": "OPEN",
      "author": "arndt-s",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just talked to you (@heymarcel)  about this and wanted to put it into writing:\n\nI believe the trust establishment is a 2 step (parent-child if you will) process:\n\n- Issuer trust establishment:\nTelling the authorization server to trust the issuer. This is most of the time the issuer URI. (e.g. AWS Identity Provider). This step is mainly about which keys to trust.\n\n- Subject trust establishment:\nThis is eventually the mapping from subject from JWT Token Issuer to Resource Owner at the Authorization Server (e.g. AWS IAM Role Trust Policy; Resource Owner is the ARN of the IAM role).\n\nI think there's value in differentiating between these two and also add some security considerations. Both levels need to be configured out of band in my opinion and are subject to policy and configuration.\n\nFor instance, AWS split those two topics into different entities and I think that's a good thing. Azure on the other hand put it together into the \"Federated Identity Credential\". It's a problem here as there's no unified view on the trusted issuer on tenant level, you would need to go into each principal individually to see if that resource owner trust a certain issuer. Not sure about GCP, but I believe their workload identity pool differentiates too and is more similar to AWS.\n\n",
      "createdAt": "2025-05-08T17:15:55Z",
      "updatedAt": "2025-05-09T21:38:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "arndt-s",
          "authorAssociation": "NONE",
          "body": "Happy to provide a PR if you agree with this :) ",
          "createdAt": "2025-05-08T17:17:05Z",
          "updatedAt": "2025-05-08T17:17:05Z"
        },
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "A PR would be much appreciated. We didn't discuss it, but there's another one outstanding: #9. I don't think it touches much on our discussion, but you may want to make sure.",
          "createdAt": "2025-05-08T17:56:00Z",
          "updatedAt": "2025-05-08T17:56:00Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOOVtHv861ym2I",
      "title": "Authentication or Authorization",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/14",
      "state": "OPEN",
      "author": "PieterKas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft uses the term authentication throughout, but the result of using the JWT is an Access Token, so in that sense it is more like an \"assertion flow\" in RFC 7523. \n\nAre there use cases where the workload authenticates, but does not receive an Access Token in return? ",
      "createdAt": "2025-05-08T19:47:45Z",
      "updatedAt": "2025-05-12T10:04:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "In my mental model, that would be a situation where the JWT is signed by an issuer that that the Authorization Server recognizes, but where the claims in the JWT are not sufficient for the AS to provide an access token.\n\nSo that would mean that there's always an authorization check for access token provisioning. I've always thought of authorization as a different problem (i.e. on the Resource Server side), but that seems too limited, now that I think of it. ",
          "createdAt": "2025-05-09T22:41:53Z",
          "updatedAt": "2025-05-09T22:41:53Z"
        },
        {
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the purpose of authentication is always to obtain an Access Token, then I think this becomes an authroization grant flow in OAuth terminology (basically RFC 7523). If there are flows where we are only using it to authenticate, but the outcome is something other than an Access Token (or Refresh Token, or other OAuth artefact), then it can be a more generic authentication flow.\n\nPerhaps the way to treat this in the spec is to have a section on \"Access Token Request using Headless JWT Authentication\" or \"Access Token Request\" which explains how this spec is used to obtain an Access Token specifically (this requires teasing authentication and authorisation apart a bit - and the opening section today does co-mingle it).\n\nIf the flow always results in an Access token, perhaps the spec should be renamed as \"Headless JWT Authorization\". Otherwise, perhaps a title of \"Headless JWT Authentication and Authorization\" with specific treatment/distinction in the speec between when it is authentication, and when it is both authentication and authorisation. ",
          "createdAt": "2025-05-12T10:04:03Z",
          "updatedAt": "2025-05-12T10:04:03Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOOVtHv861zJHl",
      "title": "Hints to the Authorization Server regarding custom (or customizable) claims",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/issues/15",
      "state": "OPEN",
      "author": "heymarcel",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "**Note:** I'm putting this here because it grew out of discussions related to this document, but I am _not_ proposing that we add it.\n\nThis is inspired by [Avaid Hahami's presentation](https://media.defcon.org/DEF%20CON%2032/DEF%20CON%2032%20presentations/DEF%20CON%2032%20-%20Aviad%20Hahami%20-%20OH-MY-DC%20-%20Abusing%20OIDC%20all%20the%20way%20to%20your%20cloud.pdf)discussing the problem of vendor-specific JWT claims in identity federation, using GitHub as an example. Here's an example set of claims:\n\n```json\n{\n  \"jti\": \"115187f5-e36a-4dd5-844f-f5b77078a388\",\n  \"sub\": \"repo:moti-banana-zurich/dvora:ref:refs/heads/main\",\n  \"aud\": \"sts.amazonaws.com\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"91accfeaa3e3bc09813ad97e6c4243d834c4875d\",\n  \"repository\": \"moti-banana-zurich/dvora\",\n  \"repository_owner\": \"moti-banana-zurich\",\n  \"repository_owner_id\": \"123456789\",\n  \"run_id\": \"123456789\",\n  \"run_number\": \"53\",\n  \"run_attempt\": \"1\",\n  \"repository_visibility\": \"private\",\n  \"repository_id\": \"123456789\",\n  \"actor_id\": \"123456789\",\n  \"actor\": \"moti-banana\",\n  \"workflow\": \"my_workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\"\n}\n```\n\nHahami demonstrates that `sub` customization combined with unsafe Authorization Server configuration, for example with the following example of IDP configuration in AWS:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::123456123456:oidcprovider/token.actions.githubusercontent.com\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\"\n        },\n        \"StringLike\": {\n          \"token.actions.githubusercontent.com:sub\": \"workflow:reusable_workflow:repo:my_org/repo\"\n        }\n      }\n    }\n  ]\n}\n```\n\nSince the rule is `StringLike` and the attacker can control their `sub`, and there are no other constraints, any GitHub Action would suffice. Hahami has published [a detailed table discussing each claim.](https://github.com/PaloAltoNetworks/github-oidc-utils)\n\nThe problem here is not solely for GitHub or AWS to solve, and it is inherent to identity federation. Practically speaking, we can assume the following will be true, or will become true over time, in order to improve vendor interoperability:\n\n1. The JWT issuer will allow custom claims.\n2. The JWT issuer will allow `sub` claim customization.\n3. The Authorization Server will allow customized federation mapping that includes string-matching.\n4. The Authorization Server will not hard-code custom claim validation for every JWT issuer.\n\nAs a start, I'm proposing a way for the JWT issuer to provide additional information about the custom claims themselves. Essentially, let's take the intent behind that table and turn it into something machine-readable, so that the Authorization Server can use it when asserting the claims in the JWT.\n\nAs a first pass, it might look something like this:\n\n```json\n{\n\t\"version\": \"2025-05-08\",\n\t\"name\": \"id-token-claim-dictionary\"\n\t\"claims\": {\n\t\t\"required\": {\n\t\t\t\"sub\": [\"user\"], \n\t\t\t\"aud\": [\"user\"]\n\t\t},\n\t\t\"custom\": {\n\t\t\t\"workflow\": [\"user\"],\n\t\t\t\"repository\": [\"system\", \"unique\"],\n\t\t\t\"run_id\": [\"system\", \"ephemeral\"],\n\t\t\t\"job_workflow_sha\": [\"system\", \"unique\"]\n\t\t}\n\t}\n}\n```\n\nNote that the tags describing each claim don't describe the _type_ of the possible claim values. They describe the characteristics that are important to know when configuring identity federation. The Authorization Server can use these as hints to prevent misconfigurations that allow unauthorized access.\n\nThis file could go in the `/.well-known/` directory. And sure, it probably should be signed.",
      "createdAt": "2025-05-08T21:01:42Z",
      "updatedAt": "2025-05-09T22:31:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "arndt-s",
          "authorAssociation": "NONE",
          "body": "I believe the following conditions need to be true in order to run into this:\n \n1. An attacker needs to be able to mint custom JWTs from the JWT issuer\n2. The mapping configuration (AWS IAM Trust Policy) needs to trust claims that are in the control of the attacker\n\nTo me, neither of these conditions should exist and I believe the draft should reflect or acknowledge this. For example by stating that:\n\n* Claims that are in control of the user should not be considered trusted or handled with extreme care.\n* JWT issuers should be segregated between trust domains. Sharing keying material between trust domains relies solely on developers to correctly set up their mapping and can easily become a foot gun.\n",
          "createdAt": "2025-05-09T08:02:23Z",
          "updatedAt": "2025-05-09T08:02:34Z"
        },
        {
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "body": "Agreed on the security recommendations for the draft. The problem itself will remain, because as Immanuel Kant pointed out, \"out of the crooked timber of humanity, no straight thing was ever made.\" \n\n(In the meantime, take a look at #9, which contains related security recommendations)\n\nIn any case, we can ignore the complicated proposal above for now. Hirsch and I met with Dick Hardt yesterday, and there's a simpler way out of this mess by recommending the use of the \"tenant\" claim as described in the [OpenID Provider Commands draft.](https://openid.github.io/openid-provider-commands/main.html).",
          "createdAt": "2025-05-09T15:45:53Z",
          "updatedAt": "2025-05-09T22:31:25Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOOVtHv86RxaHM",
      "title": "Adding Document Skeleton",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/pull/2",
      "state": "MERGED",
      "author": "PieterKas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fleshing out the specification topics",
      "createdAt": "2025-04-08T11:28:51Z",
      "updatedAt": "2025-04-08T14:07:30Z",
      "baseRepository": "heymarcel/draft-ietf-wimse-headless-jwt-authentication",
      "baseRefName": "main",
      "baseRefOid": "89db246d20ea4c7f7592e935e8e4e9bf22afd3cb",
      "headRepository": "PieterKas/draft-ietf-wimse-headless-jwt-authentication",
      "headRefName": "patch-1",
      "headRefOid": "dd771b4f061dde273898ccefddbd990045942741",
      "closedAt": "2025-04-08T14:07:30Z",
      "mergedAt": "2025-04-08T14:07:30Z",
      "mergedBy": "heymarcel",
      "mergeCommit": {
        "oid": "4790196de381af1577edc91fc85edcb695f6c97a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOVtHv86j65gR",
          "commit": {
            "abbreviatedOid": "dd771b4"
          },
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2025-04-08T14:05:15Z",
          "updatedAt": "2025-04-08T14:05:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOOVtHv86T5Urs",
      "title": "Suggested Tweaks",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/pull/7",
      "state": "MERGED",
      "author": "PieterKas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-04-25T10:53:19Z",
      "updatedAt": "2025-04-25T16:07:23Z",
      "baseRepository": "heymarcel/draft-ietf-wimse-headless-jwt-authentication",
      "baseRefName": "main",
      "baseRefOid": "e6d2414653511272170caf710af2df013888debf",
      "headRepository": "PieterKas/draft-ietf-wimse-headless-jwt-authentication",
      "headRefName": "patch-2",
      "headRefOid": "1c6145670b247b22f7469701bd76c10941c14a9e",
      "closedAt": "2025-04-25T16:07:23Z",
      "mergedAt": "2025-04-25T16:07:23Z",
      "mergedBy": "heymarcel",
      "mergeCommit": {
        "oid": "68ac58e022120fc5df15f3ba9587532c9c2e52d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOVtHv86mknG3",
          "commit": {
            "abbreviatedOid": "1c61456"
          },
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2025-04-25T16:06:06Z",
          "updatedAt": "2025-04-25T16:06:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOOVtHv86VAIE6",
      "title": "Initial proposal for addressing questions in #8",
      "url": "https://github.com/heymarcel/draft-ietf-wimse-headless-jwt-authentication/pull/9",
      "state": "OPEN",
      "author": "heymarcel",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I doubt we'll be able to address everything in the discussion, but I'd like to surface the problem in a way that opens the door for another WIMSE draft to tackle it head-on. Here's a first attempt.",
      "createdAt": "2025-05-05T21:25:18Z",
      "updatedAt": "2025-05-09T23:41:28Z",
      "baseRepository": "heymarcel/draft-ietf-wimse-headless-jwt-authentication",
      "baseRefName": "main",
      "baseRefOid": "2251bd51115afde3eedf38e90a24f417a4b65b3d",
      "headRepository": "heymarcel/draft-ietf-wimse-headless-jwt-authentication",
      "headRefName": "marcel/interop",
      "headRefOid": "8eddb1a0b0e8dfaf3d5b715273084bdd69492108",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOVtHv86oD8gy",
          "commit": {
            "abbreviatedOid": "bbd6b48"
          },
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-06T20:49:58Z",
          "updatedAt": "2025-05-06T20:49:59Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "claims aren't exchanged.",
              "createdAt": "2025-05-06T20:49:59Z",
              "updatedAt": "2025-05-06T20:49:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOVtHv86oP0lO",
          "commit": {
            "abbreviatedOid": "bbd6b48"
          },
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T17:59:19Z",
          "updatedAt": "2025-05-07T17:59:20Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The lead-in to the this sentence talks about configuration, but then this point feels more like a processing rule (e.g. what should be done at runtime). \r\n\r\nwhat is it that should be configured here?",
              "createdAt": "2025-05-07T17:59:20Z",
              "updatedAt": "2025-05-07T17:59:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOVtHv86oP0-R",
          "commit": {
            "abbreviatedOid": "bbd6b48"
          },
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T17:59:47Z",
          "updatedAt": "2025-05-07T17:59:47Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "similar to previous comment - is this a configuration, or a processing rule?",
              "createdAt": "2025-05-07T17:59:47Z",
              "updatedAt": "2025-05-07T17:59:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOVtHv86oc_ev",
          "commit": {
            "abbreviatedOid": "0df17e3"
          },
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-08T19:29:29Z",
          "updatedAt": "2025-05-08T19:29:29Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "legible = known? accepted?\r\n\r\nI am a little unclear on what this means. Thinking about something like workload identity federation, the claims are used to determine the subject of the access token issued. Is that what is really happening here?",
              "createdAt": "2025-05-08T19:29:29Z",
              "updatedAt": "2025-05-08T19:38:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOVtHv86odFjF",
          "commit": {
            "abbreviatedOid": "0df17e3"
          },
          "author": "PieterKas",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-08T19:41:59Z",
          "updatedAt": "2025-05-08T19:41:59Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I wonder if we can find a way to not refer to \"identity\" in this case - what is the actual artefact of importance? A credential? A subject identifier (that may indicate a service account, service principal or similar)?",
              "createdAt": "2025-05-08T19:41:59Z",
              "updatedAt": "2025-05-08T19:41:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOVtHv86oqwzN",
          "commit": {
            "abbreviatedOid": "0df17e3"
          },
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-09T22:12:57Z",
          "updatedAt": "2025-05-09T22:12:57Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yeah. Let me clarify.",
              "createdAt": "2025-05-09T22:12:57Z",
              "updatedAt": "2025-05-09T22:12:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOVtHv86oqxF3",
          "commit": {
            "abbreviatedOid": "0df17e3"
          },
          "author": "heymarcel",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-09T22:14:20Z",
          "updatedAt": "2025-05-09T22:14:20Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "How about just \"principal\"?",
              "createdAt": "2025-05-09T22:14:20Z",
              "updatedAt": "2025-05-09T22:14:20Z"
            }
          ]
        }
      ]
    }
  ]
}